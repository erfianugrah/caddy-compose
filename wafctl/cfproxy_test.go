package main

import (
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"testing"
	"time"
)

func TestCFProxyStoreParseFile(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "cf_trusted_proxies.caddy")

	content := `# AUTO-GENERATED by wafctl refresh
# Updated: 2026-02-28T06:00:00Z
# CIDRs: 3 (IPv4: 2, IPv6: 1)
trusted_proxies static 173.245.48.0/20 103.21.244.0/22 2400:cb00::/32
`
	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	store := NewCFProxyStore(path)
	stats := store.Stats()

	if stats.CIDRCount != 3 {
		t.Errorf("CIDRCount = %d, want 3", stats.CIDRCount)
	}
	if stats.LastUpdated != "2026-02-28T06:00:00Z" {
		t.Errorf("LastUpdated = %q, want 2026-02-28T06:00:00Z", stats.LastUpdated)
	}
}

func TestCFProxyStoreParseFileEmpty(t *testing.T) {
	store := NewCFProxyStore(filepath.Join(t.TempDir(), "nonexistent.caddy"))
	stats := store.Stats()
	if stats.CIDRCount != 0 {
		t.Errorf("CIDRCount = %d, want 0", stats.CIDRCount)
	}
}

func TestCFProxyStoreStatsHandler(t *testing.T) {
	dir := t.TempDir()
	path := filepath.Join(dir, "cf.caddy")
	os.WriteFile(path, []byte("# Updated: 2026-01-01T00:00:00Z\ntrusted_proxies static 10.0.0.0/8 192.168.0.0/16\n"), 0644)

	store := NewCFProxyStore(path)
	handler := handleCFProxyStats(store)

	req := httptest.NewRequest("GET", "/api/cfproxy/stats", nil)
	rec := httptest.NewRecorder()
	handler.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("status = %d, want 200", rec.Code)
	}
}

func TestCFProxyRefreshMockServer(t *testing.T) {
	// Mock CF IP endpoints.
	v4Server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, "173.245.48.0/20")
		fmt.Fprintln(w, "103.21.244.0/22")
	}))
	defer v4Server.Close()

	v6Server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, "2400:cb00::/32")
		fmt.Fprintln(w, "2606:4700::/32")
		fmt.Fprintln(w, "2803:f800::/32")
	}))
	defer v6Server.Close()

	// We can't easily test Refresh() since it hardcodes the CF URLs.
	// Instead test downloadCFIPs directly.
	client := &http.Client{Timeout: 5 * time.Second}

	v4, err := downloadCFIPs(client, v4Server.URL)
	if err != nil {
		t.Fatalf("downloadCFIPs v4 failed: %v", err)
	}
	if len(v4) != 2 {
		t.Errorf("v4 CIDRs = %d, want 2", len(v4))
	}

	v6, err := downloadCFIPs(client, v6Server.URL)
	if err != nil {
		t.Fatalf("downloadCFIPs v6 failed: %v", err)
	}
	if len(v6) != 3 {
		t.Errorf("v6 CIDRs = %d, want 3", len(v6))
	}
}

func TestDownloadCFIPsInvalidCIDR(t *testing.T) {
	srv := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, "173.245.48.0/20")
		fmt.Fprintln(w, "not-a-cidr")
		fmt.Fprintln(w, "103.21.244.0/22")
	}))
	defer srv.Close()

	client := &http.Client{Timeout: 5 * time.Second}
	cidrs, err := downloadCFIPs(client, srv.URL)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if len(cidrs) != 2 {
		t.Errorf("CIDRs = %d, want 2 (invalid CIDR should be skipped)", len(cidrs))
	}
}

func TestNextCFRefreshTime(t *testing.T) {
	// Wednesday 10:00 UTC — next Monday should be 5 days ahead.
	now := time.Date(2026, 2, 25, 10, 0, 0, 0, time.UTC) // Wednesday
	next := nextCFRefreshTime(now, 6)
	if next.Weekday() != time.Monday {
		t.Errorf("next = %s (weekday %s), want Monday", next, next.Weekday())
	}
	if !next.After(now) {
		t.Errorf("next %s should be after now %s", next, now)
	}

	// Monday before refresh hour — should be today.
	monday := time.Date(2026, 3, 2, 4, 0, 0, 0, time.UTC) // Monday 04:00
	next = nextCFRefreshTime(monday, 6)
	if next.Day() != 2 {
		t.Errorf("should be today (March 2), got March %d", next.Day())
	}

	// Monday after refresh hour — should be next Monday.
	mondayAfter := time.Date(2026, 3, 2, 8, 0, 0, 0, time.UTC) // Monday 08:00
	next = nextCFRefreshTime(mondayAfter, 6)
	if next.Day() != 9 {
		t.Errorf("should be next Monday (March 9), got March %d", next.Day())
	}
}
