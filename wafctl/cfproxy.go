package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

// ─── Cloudflare Trusted Proxy Store ─────────────────────────────────

// CFProxyStore manages the Cloudflare trusted_proxies Caddy snippet.
// It downloads CF IP ranges at runtime and writes a Caddy-importable file.
type CFProxyStore struct {
	filePath string
	cacheTTL time.Duration

	mu          sync.RWMutex
	cidrs       []string // parsed CIDR ranges
	lastUpdated string   // from file comment "# Updated: ..."
	lastLoad    time.Time

	refreshing atomic.Bool
}

// NewCFProxyStore creates a store that reads from the given cf_trusted_proxies.caddy file.
func NewCFProxyStore(filePath string) *CFProxyStore {
	return &CFProxyStore{
		filePath: filePath,
		cacheTTL: 5 * time.Minute,
	}
}

// parseFile reads and parses the cf_trusted_proxies.caddy file.
func (s *CFProxyStore) parseFile() {
	f, err := os.Open(s.filePath)
	if err != nil {
		if !os.IsNotExist(err) {
			log.Printf("[cfproxy] failed to open %s: %v", s.filePath, err)
		}
		return
	}
	defer f.Close()

	var cidrs []string
	var updated string

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "# Updated:") {
			updated = strings.TrimSpace(strings.TrimPrefix(line, "# Updated:"))
			continue
		}
		if strings.HasPrefix(line, "#") || strings.TrimSpace(line) == "" {
			continue
		}
		// Parse the "trusted_proxies static <cidr1> <cidr2> ..." line.
		if strings.HasPrefix(line, "trusted_proxies static") {
			fields := strings.Fields(line)
			if len(fields) > 2 {
				cidrs = fields[2:] // everything after "trusted_proxies static"
			}
		}
	}

	s.mu.Lock()
	defer s.mu.Unlock()
	s.cidrs = cidrs
	s.lastUpdated = updated
	s.lastLoad = time.Now()
}

// ensureLoaded re-reads the file if the cache TTL has expired.
func (s *CFProxyStore) ensureLoaded() {
	s.mu.RLock()
	stale := time.Since(s.lastLoad) > s.cacheTTL
	s.mu.RUnlock()
	if stale {
		s.parseFile()
	}
}

// Stats returns current CF proxy information.
func (s *CFProxyStore) Stats() CFProxyStatsResponse {
	s.ensureLoaded()
	s.mu.RLock()
	defer s.mu.RUnlock()
	return CFProxyStatsResponse{
		CIDRCount:   len(s.cidrs),
		LastUpdated: s.lastUpdated,
		Source:      "cloudflare.com/ips-v4 + /ips-v6",
		FilePath:    s.filePath,
	}
}

// Refresh downloads fresh Cloudflare IP ranges, writes the Caddy snippet, and
// reloads Caddy. Returns a response suitable for the API.
func (s *CFProxyStore) Refresh(deployCfg DeployConfig) CFProxyRefreshResponse {
	if !s.refreshing.CompareAndSwap(false, true) {
		return CFProxyRefreshResponse{
			Status:  "error",
			Message: "refresh already in progress",
		}
	}
	defer s.refreshing.Store(false)

	log.Printf("[cfproxy] refreshing Cloudflare IP ranges")

	client := &http.Client{Timeout: 30 * time.Second}

	// Download IPv4 and IPv6 ranges.
	v4, err := downloadCFIPs(client, "https://www.cloudflare.com/ips-v4")
	if err != nil {
		log.Printf("[cfproxy] IPv4 download failed: %v", err)
		return CFProxyRefreshResponse{Status: "error", Message: fmt.Sprintf("IPv4 download failed: %v", err)}
	}
	v6, err := downloadCFIPs(client, "https://www.cloudflare.com/ips-v6")
	if err != nil {
		log.Printf("[cfproxy] IPv6 download failed: %v", err)
		return CFProxyRefreshResponse{Status: "error", Message: fmt.Sprintf("IPv6 download failed: %v", err)}
	}

	all := append(v4, v6...)

	// Safety check: CF currently has ~15 v4 + ~7 v6 = ~22 ranges.
	if len(all) < 5 {
		msg := fmt.Sprintf("too few CIDRs (%d), aborting to prevent broken trusted_proxies", len(all))
		log.Printf("[cfproxy] %s", msg)
		return CFProxyRefreshResponse{Status: "error", Message: msg}
	}

	// Generate Caddy-importable snippet.
	now := time.Now().UTC().Format(time.RFC3339)
	cidrLine := strings.Join(all, " ")
	content := fmt.Sprintf("# AUTO-GENERATED by wafctl refresh — do not edit manually\n# Updated: %s\n# CIDRs: %d (IPv4: %d, IPv6: %d)\ntrusted_proxies static %s\n",
		now, len(all), len(v4), len(v6), cidrLine)

	// Atomic write.
	dir := filepath.Dir(s.filePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		msg := fmt.Sprintf("failed to create directory %s: %v", dir, err)
		log.Printf("[cfproxy] %s", msg)
		return CFProxyRefreshResponse{Status: "error", Message: msg}
	}

	if err := atomicWriteFile(s.filePath, []byte(content), 0644); err != nil {
		msg := fmt.Sprintf("failed to write CF proxies: %v", err)
		log.Printf("[cfproxy] %s", msg)
		return CFProxyRefreshResponse{Status: "error", Message: msg}
	}

	log.Printf("[cfproxy] wrote %d CIDRs to %s", len(all), s.filePath)

	// Force-reload in-memory cache.
	s.parseFile()

	// Reload Caddy so the new trusted_proxies take effect.
	reloaded := true
	if err := reloadCaddy(deployCfg.CaddyfilePath, deployCfg.CaddyAdminURL, s.filePath); err != nil {
		log.Printf("[cfproxy] warning: Caddy reload failed: %v", err)
		reloaded = false
	}

	status := "updated"
	msg := fmt.Sprintf("Downloaded %d CIDRs and updated trusted proxies", len(all))
	if !reloaded {
		status = "partial"
		msg += " (Caddy reload failed — manual reload may be needed)"
	}

	return CFProxyRefreshResponse{
		Status:      status,
		Message:     msg,
		CIDRCount:   len(all),
		IPv4Count:   len(v4),
		IPv6Count:   len(v6),
		LastUpdated: now,
		Reloaded:    reloaded,
	}
}

// downloadCFIPs fetches a Cloudflare IP list URL and returns validated CIDRs.
func downloadCFIPs(client *http.Client, url string) ([]string, error) {
	resp, err := client.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(body))
	}

	var cidrs []string
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		cidr := strings.TrimSpace(scanner.Text())
		if cidr == "" {
			continue
		}
		// Validate CIDR.
		_, _, err := net.ParseCIDR(cidr)
		if err != nil {
			log.Printf("[cfproxy] skipping invalid CIDR %q: %v", cidr, err)
			continue
		}
		cidrs = append(cidrs, cidr)
	}
	return cidrs, scanner.Err()
}

// StartScheduledRefresh launches a background goroutine that refreshes
// CF IPs weekly at the specified UTC hour.
func (s *CFProxyStore) StartScheduledRefresh(hour int, deployCfg DeployConfig) {
	go func() {
		for {
			now := time.Now().UTC()
			next := nextCFRefreshTime(now, hour)
			delay := next.Sub(now)
			log.Printf("[cfproxy] next scheduled refresh at %s (in %s)", next.Format(time.RFC3339), delay.Round(time.Second))

			time.Sleep(delay)

			log.Printf("[cfproxy] starting scheduled refresh")
			result := s.Refresh(deployCfg)
			log.Printf("[cfproxy] scheduled refresh complete: status=%s message=%q cidrs=%d", result.Status, result.Message, result.CIDRCount)
		}
	}()
}

// nextCFRefreshTime returns the next Monday at the given UTC hour.
// If that time has already passed this week, it returns next Monday.
func nextCFRefreshTime(now time.Time, hour int) time.Time {
	// Find next Monday.
	daysUntilMonday := (time.Monday - now.Weekday() + 7) % 7
	if daysUntilMonday == 0 {
		// It's Monday — check if the hour has passed.
		target := time.Date(now.Year(), now.Month(), now.Day(), hour, 0, 0, 0, time.UTC)
		if target.After(now) {
			return target
		}
		daysUntilMonday = 7
	}
	next := time.Date(now.Year(), now.Month(), now.Day()+int(daysUntilMonday), hour, 0, 0, 0, time.UTC)
	return next
}

// ─── HTTP Handlers ──────────────────────────────────────────────────

func handleCFProxyStats(s *CFProxyStore) http.HandlerFunc {
	return func(w http.ResponseWriter, _ *http.Request) {
		writeJSON(w, http.StatusOK, s.Stats())
	}
}

func handleCFProxyRefresh(s *CFProxyStore, deployCfg DeployConfig) http.HandlerFunc {
	return func(w http.ResponseWriter, _ *http.Request) {
		result := s.Refresh(deployCfg)
		status := http.StatusOK
		if result.Status == "error" {
			status = http.StatusInternalServerError
		}
		writeJSON(w, status, result)
	}
}
