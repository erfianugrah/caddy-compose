package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

// defaultBlocklistMinScore is the minimum IPsum score to include in the blocklist.
// IPs with fewer independent blocklist appearances are excluded.
const defaultBlocklistMinScore = 3

// BlocklistStore caches the parsed ipsum blocklist file.
// The file is re-read at most every cacheTTL to avoid hammering disk.
type BlocklistStore struct {
	filePath string
	cacheTTL time.Duration

	mu          sync.RWMutex
	ips         map[string]struct{} // set of blocked IPs
	ipCount     int
	lastUpdated string // from file comment "# Updated: ..."
	minScore    int    // from file comment "# IPs: ... (min_score=N)"
	lastLoad    time.Time

	refreshing atomic.Bool // guard against concurrent Refresh calls
}

// NewBlocklistStore creates a store that reads from the given ipsum_block.caddy file.
func NewBlocklistStore(filePath string) *BlocklistStore {
	return &BlocklistStore{
		filePath: filePath,
		cacheTTL: 5 * time.Minute,
		ips:      make(map[string]struct{}),
	}
}

// parseFile reads and parses the ipsum_block.caddy file.
// Expected format:
//
//	# AUTO-GENERATED by wafctl refresh — do not edit manually
//	# Updated: 2026-02-22T06:00:01Z
//	# IPs: 19823 (min_score=3)
//	# Source: https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt
//	@ipsum_blocked client_ip 1.2.3.4 5.6.7.8 ...
//	route @ipsum_blocked { ... }
func (bs *BlocklistStore) parseFile() {
	f, err := os.Open(bs.filePath)
	if err != nil {
		log.Printf("[blocklist] cannot open %s: %v", bs.filePath, err)
		return
	}
	defer f.Close()

	// Stat the file for mtime fallback if "# Updated:" comment is missing.
	var fileMtime time.Time
	if info, err := f.Stat(); err == nil {
		fileMtime = info.ModTime()
	}

	ips := make(map[string]struct{})
	var lastUpdated string
	minScore := defaultBlocklistMinScore

	scanner := bufio.NewScanner(f)
	// The @ipsum_blocked line can be very long (20k+ IPs).
	scanner.Buffer(make([]byte, 0, 64*1024), 4*1024*1024)

	for scanner.Scan() {
		line := scanner.Text()

		// Parse metadata from comments.
		if strings.HasPrefix(line, "# Updated:") {
			lastUpdated = strings.TrimSpace(strings.TrimPrefix(line, "# Updated:"))
			continue
		}
		if strings.HasPrefix(line, "# IPs:") {
			// Format: "# IPs: 19823 (min_score=3)"
			rest := strings.TrimPrefix(line, "# IPs:")
			rest = strings.TrimSpace(rest)
			if idx := strings.Index(rest, "(min_score="); idx >= 0 {
				scoreStr := rest[idx+len("(min_score="):]
				if end := strings.Index(scoreStr, ")"); end >= 0 {
					if n, err := strconv.Atoi(scoreStr[:end]); err == nil {
						minScore = n
					}
				}
			}
			continue
		}

		// Parse the IP list line.
		if strings.HasPrefix(line, "@ipsum_blocked client_ip ") {
			ipList := strings.TrimPrefix(line, "@ipsum_blocked client_ip ")
			for _, ip := range strings.Fields(ipList) {
				ips[ip] = struct{}{}
			}
			continue
		}
	}

	// Fallback: if no "# Updated:" comment was found, use the file's mtime.
	if lastUpdated == "" && !fileMtime.IsZero() {
		lastUpdated = fileMtime.UTC().Format(time.RFC3339)
		log.Printf("[blocklist] no '# Updated:' comment in %s, using file mtime: %s", bs.filePath, lastUpdated)
	}

	bs.mu.Lock()
	bs.ips = ips
	bs.ipCount = len(ips)
	bs.lastUpdated = lastUpdated
	bs.minScore = minScore
	bs.lastLoad = time.Now()
	bs.mu.Unlock()
}

// ensureLoaded re-parses the file if the cache has expired.
func (bs *BlocklistStore) ensureLoaded() {
	bs.mu.RLock()
	stale := time.Since(bs.lastLoad) > bs.cacheTTL
	bs.mu.RUnlock()

	if stale {
		bs.parseFile()
	}
}

// Stats returns blocklist statistics.
func (bs *BlocklistStore) Stats() BlocklistStatsResponse {
	bs.ensureLoaded()
	bs.mu.RLock()
	defer bs.mu.RUnlock()
	return BlocklistStatsResponse{
		BlockedIPs:  bs.ipCount,
		LastUpdated: bs.lastUpdated,
		Source:      "IPsum",
		MinScore:    bs.minScore,
		FilePath:    bs.filePath,
	}
}

// Check returns whether a given IP is in the blocklist.
func (bs *BlocklistStore) Check(ip string) BlocklistCheckResponse {
	bs.ensureLoaded()
	bs.mu.RLock()
	defer bs.mu.RUnlock()
	_, blocked := bs.ips[ip]
	return BlocklistCheckResponse{
		IP:      ip,
		Blocked: blocked,
		Source:  "IPsum",
	}
}

// ForceReload re-parses the blocklist file immediately, bypassing the cache TTL.
func (bs *BlocklistStore) ForceReload() {
	bs.parseFile()
}

// Refresh downloads a fresh IPsum blocklist, writes the Caddy snippet, and
// reloads the in-memory cache. Returns a response suitable for the API.
// The deployCfg is used to reload Caddy after writing the file.
func (bs *BlocklistStore) Refresh(deployCfg DeployConfig) BlocklistRefreshResponse {
	// Prevent concurrent refreshes — the operation is expensive (HTTP download,
	// file write, Caddy reload) and concurrent runs would race on file writes.
	if !bs.refreshing.CompareAndSwap(false, true) {
		return BlocklistRefreshResponse{
			Status:  "error",
			Message: "refresh already in progress",
		}
	}
	defer bs.refreshing.Store(false)

	const ipsumURL = "https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt"

	bs.mu.RLock()
	minScore := bs.minScore
	bs.mu.RUnlock()
	if minScore < 1 {
		minScore = defaultBlocklistMinScore
	}

	log.Printf("[blocklist] refreshing from %s (min_score=%d)", ipsumURL, minScore)

	// Download the raw list.
	client := &http.Client{Timeout: 60 * time.Second}
	resp, err := client.Get(ipsumURL)
	if err != nil {
		log.Printf("[blocklist] download failed: %v", err)
		return BlocklistRefreshResponse{
			Status:  "error",
			Message: fmt.Sprintf("download failed: %v", err),
		}
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		log.Printf("[blocklist] download returned %d: %s", resp.StatusCode, string(body))
		return BlocklistRefreshResponse{
			Status:  "error",
			Message: fmt.Sprintf("download returned HTTP %d", resp.StatusCode),
		}
	}

	// Parse the IPsum format: lines are "IP\tSCORE" with # comments.
	var ips []string
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "#") || strings.TrimSpace(line) == "" {
			continue
		}
		fields := strings.Fields(line)
		if len(fields) < 2 {
			continue
		}
		score, err := strconv.Atoi(fields[1])
		if err != nil {
			continue
		}
		if score >= minScore {
			ips = append(ips, fields[0])
		}
	}

	if len(ips) < 10 {
		msg := fmt.Sprintf("too few IPs (%d), aborting to prevent empty blocklist", len(ips))
		log.Printf("[blocklist] %s", msg)
		return BlocklistRefreshResponse{
			Status:  "error",
			Message: msg,
		}
	}

	// Generate Caddy-importable snippet.
	now := time.Now().UTC().Format(time.RFC3339)
	ipLine := strings.Join(ips, " ")
	content := fmt.Sprintf(`# AUTO-GENERATED by wafctl refresh — do not edit manually
# Updated: %s
# IPs: %d (min_score=%d)
# Source: %s
@ipsum_blocked client_ip %s
route @ipsum_blocked {
	header X-Blocked-By ipsum
	respond 403 {
		body "Blocked"
		close
	}
}
`, now, len(ips), minScore, ipsumURL, ipLine)

	// Atomic write to the blocklist file.
	dir := filepath.Dir(bs.filePath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		msg := fmt.Sprintf("failed to create directory %s: %v", dir, err)
		log.Printf("[blocklist] %s", msg)
		return BlocklistRefreshResponse{Status: "error", Message: msg}
	}

	if err := atomicWriteFile(bs.filePath, []byte(content), 0644); err != nil {
		msg := fmt.Sprintf("failed to write blocklist: %v", err)
		log.Printf("[blocklist] %s", msg)
		return BlocklistRefreshResponse{Status: "error", Message: msg}
	}

	log.Printf("[blocklist] wrote %d IPs to %s", len(ips), bs.filePath)

	// Force-reload the in-memory cache from the new file.
	bs.ForceReload()

	// Reload Caddy so the new blocklist takes effect.
	reloaded := true
	if err := reloadCaddy(deployCfg.CaddyfilePath, deployCfg.CaddyAdminURL, bs.filePath); err != nil {
		log.Printf("[blocklist] warning: Caddy reload failed: %v", err)
		reloaded = false
	}

	status := "updated"
	msg := fmt.Sprintf("Downloaded %d IPs and updated blocklist", len(ips))
	if !reloaded {
		status = "partial"
		msg += " (Caddy reload failed — manual reload may be needed)"
	}

	return BlocklistRefreshResponse{
		Status:      status,
		Message:     msg,
		BlockedIPs:  len(ips),
		MinScore:    minScore,
		LastUpdated: now,
		Reloaded:    reloaded,
	}
}

// --- Scheduled Refresh ---

// nextRefreshTime returns the next UTC time at the given hour (0–23).
// If that hour has already passed today, it returns tomorrow at that hour.
func nextRefreshTime(now time.Time, hour int) time.Time {
	next := time.Date(now.Year(), now.Month(), now.Day(), hour, 0, 0, 0, time.UTC)
	if !next.After(now) {
		next = next.Add(24 * time.Hour)
	}
	return next
}

// StartScheduledRefresh launches a background goroutine that refreshes the
// blocklist daily at the specified UTC hour. This replaces the cron-based
// update-ipsum.sh approach, which was unreliable inside hardened containers
// (BusyBox crond silently skips crontabs with wrong file permissions).
func (bs *BlocklistStore) StartScheduledRefresh(hour int, deployCfg DeployConfig, rs *RateLimitRuleStore) {
	go func() {
		for {
			now := time.Now().UTC()
			next := nextRefreshTime(now, hour)
			delay := next.Sub(now)
			log.Printf("[blocklist] next scheduled refresh at %s (in %s)", next.Format(time.RFC3339), delay.Round(time.Second))

			time.Sleep(delay)

			log.Printf("[blocklist] starting scheduled refresh")
			syncCaddyfileServices(rs, deployCfg)
			result := bs.Refresh(deployCfg)
			log.Printf("[blocklist] scheduled refresh complete: status=%s message=%q ips=%d", result.Status, result.Message, result.BlockedIPs)
		}
	}()
}

// --- HTTP Handlers ---

func handleBlocklistStats(bs *BlocklistStore) http.HandlerFunc {
	return func(w http.ResponseWriter, _ *http.Request) {
		writeJSON(w, http.StatusOK, bs.Stats())
	}
}

func handleBlocklistCheck(bs *BlocklistStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ip := r.PathValue("ip")
		if ip == "" {
			writeJSON(w, http.StatusBadRequest, ErrorResponse{Error: "IP address is required"})
			return
		}
		if net.ParseIP(ip) == nil {
			writeJSON(w, http.StatusBadRequest, ErrorResponse{Error: "invalid IP address"})
			return
		}
		writeJSON(w, http.StatusOK, bs.Check(ip))
	}
}

func handleBlocklistRefresh(bs *BlocklistStore, rs *RateLimitRuleStore, deployCfg DeployConfig) http.HandlerFunc {
	return func(w http.ResponseWriter, _ *http.Request) {
		// Ensure any new Caddyfile services have rate limit files before Caddy reloads.
		syncCaddyfileServices(rs, deployCfg)

		result := bs.Refresh(deployCfg)
		status := http.StatusOK
		if result.Status == "error" {
			status = http.StatusInternalServerError
		}
		writeJSON(w, status, result)
	}
}
