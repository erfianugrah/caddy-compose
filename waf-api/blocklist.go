package main

import (
	"bufio"
	"net"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"
)

// BlocklistStore caches the parsed ipsum blocklist file.
// The file is re-read at most every cacheTTL to avoid hammering disk.
type BlocklistStore struct {
	filePath string
	cacheTTL time.Duration

	mu          sync.RWMutex
	ips         map[string]struct{} // set of blocked IPs
	ipCount     int
	lastUpdated string // from file comment "# Updated: ..."
	minScore    int    // from file comment "# IPs: ... (min_score=N)"
	lastLoad    time.Time
}

// NewBlocklistStore creates a store that reads from the given ipsum_block.caddy file.
func NewBlocklistStore(filePath string) *BlocklistStore {
	return &BlocklistStore{
		filePath: filePath,
		cacheTTL: 5 * time.Minute,
		ips:      make(map[string]struct{}),
	}
}

// parseFile reads and parses the ipsum_block.caddy file.
// Expected format:
//
//	# AUTO-GENERATED by update-ipsum.sh â€” do not edit manually
//	# Updated: 2026-02-22T06:00:01Z
//	# IPs: 19823 (min_score=3)
//	# Source: https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt
//	@ipsum_blocked client_ip 1.2.3.4 5.6.7.8 ...
//	route @ipsum_blocked { ... }
func (bs *BlocklistStore) parseFile() {
	f, err := os.Open(bs.filePath)
	if err != nil {
		return
	}
	defer f.Close()

	ips := make(map[string]struct{})
	var lastUpdated string
	minScore := 3 // default

	scanner := bufio.NewScanner(f)
	// The @ipsum_blocked line can be very long (20k+ IPs).
	scanner.Buffer(make([]byte, 0, 64*1024), 4*1024*1024)

	for scanner.Scan() {
		line := scanner.Text()

		// Parse metadata from comments.
		if strings.HasPrefix(line, "# Updated:") {
			lastUpdated = strings.TrimSpace(strings.TrimPrefix(line, "# Updated:"))
			continue
		}
		if strings.HasPrefix(line, "# IPs:") {
			// Format: "# IPs: 19823 (min_score=3)"
			rest := strings.TrimPrefix(line, "# IPs:")
			rest = strings.TrimSpace(rest)
			if idx := strings.Index(rest, "(min_score="); idx >= 0 {
				scoreStr := rest[idx+len("(min_score="):]
				if end := strings.Index(scoreStr, ")"); end >= 0 {
					if n, err := strconv.Atoi(scoreStr[:end]); err == nil {
						minScore = n
					}
				}
			}
			continue
		}

		// Parse the IP list line.
		if strings.HasPrefix(line, "@ipsum_blocked client_ip ") {
			ipList := strings.TrimPrefix(line, "@ipsum_blocked client_ip ")
			for _, ip := range strings.Fields(ipList) {
				ips[ip] = struct{}{}
			}
			continue
		}
	}

	bs.mu.Lock()
	bs.ips = ips
	bs.ipCount = len(ips)
	bs.lastUpdated = lastUpdated
	bs.minScore = minScore
	bs.lastLoad = time.Now()
	bs.mu.Unlock()
}

// ensureLoaded re-parses the file if the cache has expired.
func (bs *BlocklistStore) ensureLoaded() {
	bs.mu.RLock()
	stale := time.Since(bs.lastLoad) > bs.cacheTTL
	bs.mu.RUnlock()

	if stale {
		bs.parseFile()
	}
}

// Stats returns blocklist statistics.
func (bs *BlocklistStore) Stats() BlocklistStatsResponse {
	bs.ensureLoaded()
	bs.mu.RLock()
	defer bs.mu.RUnlock()
	return BlocklistStatsResponse{
		BlockedIPs:  bs.ipCount,
		LastUpdated: bs.lastUpdated,
		Source:      "IPsum",
		MinScore:    bs.minScore,
		FilePath:    bs.filePath,
	}
}

// Check returns whether a given IP is in the blocklist.
func (bs *BlocklistStore) Check(ip string) BlocklistCheckResponse {
	bs.ensureLoaded()
	bs.mu.RLock()
	defer bs.mu.RUnlock()
	_, blocked := bs.ips[ip]
	return BlocklistCheckResponse{
		IP:      ip,
		Blocked: blocked,
		Source:  "IPsum",
	}
}

// --- HTTP Handlers ---

func handleBlocklistStats(bs *BlocklistStore) http.HandlerFunc {
	return func(w http.ResponseWriter, _ *http.Request) {
		writeJSON(w, http.StatusOK, bs.Stats())
	}
}

func handleBlocklistCheck(bs *BlocklistStore) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ip := r.PathValue("ip")
		if ip == "" {
			writeJSON(w, http.StatusBadRequest, ErrorResponse{Error: "IP address is required"})
			return
		}
		if net.ParseIP(ip) == nil {
			writeJSON(w, http.StatusBadRequest, ErrorResponse{Error: "invalid IP address"})
			return
		}
		writeJSON(w, http.StatusOK, bs.Check(ip))
	}
}
