package main

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"
)


func TestBlocklistStatsParseFile(t *testing.T) {
	content := `# AUTO-GENERATED by update-ipsum.sh — do not edit manually
# Updated: 2026-02-22T06:00:01Z
# IPs: 3 (min_score=3)
# Source: https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt
@ipsum_blocked client_ip 1.2.3.4 5.6.7.8 9.10.11.12
route @ipsum_blocked {
	header X-Blocked-By ipsum
	respond 403 {
		body "Blocked"
		close
	}
}
`
	path := writeTempBlocklist(t, content)
	bs := NewBlocklistStore(path)

	stats := bs.Stats()
	if stats.BlockedIPs != 3 {
		t.Errorf("BlockedIPs: want 3, got %d", stats.BlockedIPs)
	}
	if stats.LastUpdated != "2026-02-22T06:00:01Z" {
		t.Errorf("LastUpdated: want 2026-02-22T06:00:01Z, got %q", stats.LastUpdated)
	}
	if stats.MinScore != 3 {
		t.Errorf("MinScore: want 3, got %d", stats.MinScore)
	}
	if stats.Source != "IPsum" {
		t.Errorf("Source: want IPsum, got %q", stats.Source)
	}
}



func TestBlocklistCheckIP(t *testing.T) {
	content := `# Updated: 2026-02-22T06:00:01Z
# IPs: 2 (min_score=3)
@ipsum_blocked client_ip 1.2.3.4 5.6.7.8
route @ipsum_blocked {
	respond 403
}
`
	path := writeTempBlocklist(t, content)
	bs := NewBlocklistStore(path)

	// Blocked IP
	result := bs.Check("1.2.3.4")
	if !result.Blocked {
		t.Error("1.2.3.4 should be blocked")
	}
	if result.Source != "IPsum" {
		t.Errorf("Source: want IPsum, got %q", result.Source)
	}

	// Clean IP
	result = bs.Check("10.0.0.1")
	if result.Blocked {
		t.Error("10.0.0.1 should not be blocked")
	}
}



func TestBlocklistDefaultMinScore(t *testing.T) {
	// File without a min_score comment should use defaultBlocklistMinScore.
	content := `# Updated: 2026-02-22T06:00:01Z
@ipsum_blocked client_ip 1.2.3.4 5.6.7.8
route @ipsum_blocked { respond 403 }
`
	path := writeTempBlocklist(t, content)
	bs := NewBlocklistStore(path)

	stats := bs.Stats()
	if stats.MinScore != defaultBlocklistMinScore {
		t.Errorf("MinScore: want %d (defaultBlocklistMinScore), got %d", defaultBlocklistMinScore, stats.MinScore)
	}
}



func TestBlocklistStatsEndpoint(t *testing.T) {
	content := `# Updated: 2026-02-22T06:00:01Z
# IPs: 2 (min_score=5)
@ipsum_blocked client_ip 1.2.3.4 5.6.7.8
route @ipsum_blocked { respond 403 }
`
	path := writeTempBlocklist(t, content)
	bs := NewBlocklistStore(path)

	req := httptest.NewRequest("GET", "/api/blocklist/stats", nil)
	w := httptest.NewRecorder()
	handleBlocklistStats(bs)(w, req)

	if w.Code != 200 {
		t.Fatalf("status: want 200, got %d", w.Code)
	}
	var resp BlocklistStatsResponse
	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatal(err)
	}
	if resp.BlockedIPs != 2 {
		t.Errorf("BlockedIPs: want 2, got %d", resp.BlockedIPs)
	}
	if resp.MinScore != 5 {
		t.Errorf("MinScore: want 5, got %d", resp.MinScore)
	}
}



func TestBlocklistCheckEndpoint(t *testing.T) {
	content := `@ipsum_blocked client_ip 1.2.3.4
route @ipsum_blocked { respond 403 }
`
	path := writeTempBlocklist(t, content)
	bs := NewBlocklistStore(path)

	// Check blocked IP
	req := httptest.NewRequest("GET", "/api/blocklist/check/1.2.3.4", nil)
	req.SetPathValue("ip", "1.2.3.4")
	w := httptest.NewRecorder()
	handleBlocklistCheck(bs)(w, req)

	if w.Code != 200 {
		t.Fatalf("status: want 200, got %d", w.Code)
	}
	var resp BlocklistCheckResponse
	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatal(err)
	}
	if !resp.Blocked {
		t.Error("1.2.3.4 should be blocked")
	}

	// Check clean IP
	req = httptest.NewRequest("GET", "/api/blocklist/check/10.0.0.1", nil)
	req.SetPathValue("ip", "10.0.0.1")
	w = httptest.NewRecorder()
	handleBlocklistCheck(bs)(w, req)

	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatal(err)
	}
	if resp.Blocked {
		t.Error("10.0.0.1 should not be blocked")
	}
}



func TestBlocklistCheckInvalidIP(t *testing.T) {
	bs := NewBlocklistStore("/nonexistent")

	req := httptest.NewRequest("GET", "/api/blocklist/check/notanip", nil)
	req.SetPathValue("ip", "notanip")
	w := httptest.NewRecorder()
	handleBlocklistCheck(bs)(w, req)

	if w.Code != 400 {
		t.Fatalf("status: want 400, got %d", w.Code)
	}
}



func TestBlocklistEmptyFile(t *testing.T) {
	path := writeTempBlocklist(t, "")
	bs := NewBlocklistStore(path)

	stats := bs.Stats()
	if stats.BlockedIPs != 0 {
		t.Errorf("BlockedIPs: want 0, got %d", stats.BlockedIPs)
	}
}



func TestBlocklistMtimeFallback(t *testing.T) {
	// File with IPs but no "# Updated:" comment — simulates pre-fix builds.
	content := `@ipsum_blocked client_ip 1.2.3.4 5.6.7.8
route @ipsum_blocked { respond 403 }
`
	path := writeTempBlocklist(t, content)
	bs := NewBlocklistStore(path)

	stats := bs.Stats()
	if stats.BlockedIPs != 2 {
		t.Errorf("BlockedIPs: want 2, got %d", stats.BlockedIPs)
	}
	// Should fall back to file mtime instead of returning empty string.
	if stats.LastUpdated == "" {
		t.Error("LastUpdated should not be empty — mtime fallback should have been used")
	}
	// Verify it's a valid RFC3339 timestamp.
	if _, err := time.Parse(time.RFC3339, stats.LastUpdated); err != nil {
		t.Errorf("LastUpdated %q is not valid RFC3339: %v", stats.LastUpdated, err)
	}
}



func TestBlocklistUpdatedHeaderPreferred(t *testing.T) {
	// File WITH "# Updated:" comment — the comment value should be used, not mtime.
	content := `# Updated: 2026-01-15T12:00:00Z
@ipsum_blocked client_ip 1.2.3.4
route @ipsum_blocked { respond 403 }
`
	path := writeTempBlocklist(t, content)
	bs := NewBlocklistStore(path)

	stats := bs.Stats()
	if stats.LastUpdated != "2026-01-15T12:00:00Z" {
		t.Errorf("LastUpdated: want 2026-01-15T12:00:00Z, got %q", stats.LastUpdated)
	}
}



func TestBlocklistNonexistentFile(t *testing.T) {
	bs := NewBlocklistStore("/nonexistent/ipsum_block.caddy")

	stats := bs.Stats()
	if stats.BlockedIPs != 0 {
		t.Errorf("BlockedIPs: want 0, got %d", stats.BlockedIPs)
	}
	if stats.LastUpdated != "" {
		t.Errorf("LastUpdated: want empty, got %q", stats.LastUpdated)
	}
}



func TestBlocklistForceReload(t *testing.T) {
	// Write file, load, then overwrite with different content and force-reload.
	content1 := `# Updated: 2026-01-01T00:00:00Z
@ipsum_blocked client_ip 1.2.3.4
route @ipsum_blocked { respond 403 }
`
	path := writeTempBlocklist(t, content1)
	bs := NewBlocklistStore(path)

	stats := bs.Stats()
	if stats.BlockedIPs != 1 {
		t.Fatalf("initial BlockedIPs: want 1, got %d", stats.BlockedIPs)
	}

	// Overwrite with more IPs.
	content2 := `# Updated: 2026-02-01T00:00:00Z
@ipsum_blocked client_ip 1.2.3.4 5.6.7.8 9.10.11.12
route @ipsum_blocked { respond 403 }
`
	if err := os.WriteFile(path, []byte(content2), 0644); err != nil {
		t.Fatal(err)
	}

	// Without ForceReload, Stats would still show 1 IP (cache TTL not expired).
	bs.ForceReload()
	stats = bs.Stats()
	if stats.BlockedIPs != 3 {
		t.Errorf("after ForceReload BlockedIPs: want 3, got %d", stats.BlockedIPs)
	}
	if stats.LastUpdated != "2026-02-01T00:00:00Z" {
		t.Errorf("LastUpdated: want 2026-02-01T00:00:00Z, got %q", stats.LastUpdated)
	}
}



func TestBlocklistRefreshEndpoint(t *testing.T) {
	// Mock IPsum server returning a small list.
	ipsumData := `# IPsum test data
# comment line
1.2.3.4	5
5.6.7.8	3
9.10.11.12	1
10.0.0.1	4
`
	ipsumServer := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Write([]byte(ipsumData))
	}))
	defer ipsumServer.Close()

	// The Refresh method uses a hardcoded URL, so we test the handler through
	// the handler endpoint instead. But for a unit test of the handler itself,
	// we can test the response shape with a mock Caddy admin.
	caddyAdmin := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.WriteHeader(200)
	}))
	defer caddyAdmin.Close()

	dir := t.TempDir()
	path := filepath.Join(dir, "ipsum_block.caddy")
	// Write an initial file so the store has something.
	os.WriteFile(path, []byte("@ipsum_blocked client_ip 1.1.1.1\nroute @ipsum_blocked { respond 403 }\n"), 0644)

	bs := NewBlocklistStore(path)
	deployCfg := DeployConfig{
		CorazaDir:     dir,
		CaddyfilePath: filepath.Join(dir, "Caddyfile"),
		CaddyAdminURL: caddyAdmin.URL,
	}

	// Write a minimal Caddyfile for the reload to read.
	os.WriteFile(deployCfg.CaddyfilePath, []byte("localhost\n"), 0644)

	req := httptest.NewRequest("POST", "/api/blocklist/refresh", nil)
	w := httptest.NewRecorder()
	rs := NewRateLimitStore(filepath.Join(t.TempDir(), "rl.json"))
	handleBlocklistRefresh(bs, rs, deployCfg)(w, req)

	// The handler calls the real IPsum URL, so in CI this might fail.
	// We just verify the handler doesn't panic and returns valid JSON.
	if w.Code != 200 && w.Code != 500 {
		t.Fatalf("unexpected status: %d", w.Code)
	}

	var resp BlocklistRefreshResponse
	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
		t.Fatalf("failed to decode response: %v", err)
	}
	if resp.Status == "" {
		t.Error("response Status should not be empty")
	}
	if resp.Message == "" {
		t.Error("response Message should not be empty")
	}
}

// ─── Client count merging tests ─────────────────────────────────────



func TestBlocklistRefreshRaceGuard(t *testing.T) {
	// Create a blocklist store and verify concurrent Refresh calls are rejected.
	bs := NewBlocklistStore(filepath.Join(t.TempDir(), "ipsum_block.caddy"))
	// Manually set refreshing to simulate an in-progress refresh.
	bs.refreshing.Store(true)

	resp := bs.Refresh(DeployConfig{})
	if resp.Status != "error" {
		t.Errorf("expected error status for concurrent refresh, got %q", resp.Status)
	}
	if !strings.Contains(resp.Message, "already in progress") {
		t.Errorf("expected 'already in progress' message, got %q", resp.Message)
	}

	// Clear the flag and verify Refresh can proceed (it will fail on HTTP but that's ok).
	bs.refreshing.Store(false)
	resp2 := bs.Refresh(DeployConfig{CaddyAdminURL: "http://localhost:0"})
	// Should not get "already in progress" error — it should attempt the download.
	if strings.Contains(resp2.Message, "already in progress") {
		t.Error("refresh should have proceeded after clearing the flag")
	}
}
